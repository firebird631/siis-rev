Prioritaire
===========

- gestion des trades en local (paper trader ultra rapide)
- gestion des statistiques par strategies
- gestion des statistiques par account (paper trader local)
- gestion du cycle de vie (fin de vie des trades par le tradeManager/traderProxy/local
- handler()->traderProxy()->freeTrade(trade); quand un trade est supprimé totalement (donc après que le localtrader ou distanttrader)
- fixer les size sur connectormessagereceivetickaggreged.cpp

- completer les stats void Strategy::addClosedTrade(Trade *trade)

- events to REDIS
  - trades entry, update, exit
  - strategy results update
  - account details (balance...) initial, update
- events from REDIS
  - ...

- connector postgresql à terminer
  - postgresql load market info data
  - postgresql load market ohlc + initial fetching
  - postgresql load market liquidation
  - postgresql load/save user trader state <=> strategy data ?
  - postgresql load/save user active/pending trades data

- ind margin trade
  - open, close, remove, modify tp, modify sl, order events, position events

- signaux :
  - order create, canceled, deleted, traded (partially, completed), error
  - position create, updated, modified, closed, deleted
  - account asset balance, balance

- stdtrademanager : pourrait avoir deux hashmap orderId et orderRefId pour retrouver plus rapidement le trade associé
  - mais demande un insert/remove et de garder les hashmap à jour

- strategy contexts
  - builder
  - init
  - trade life-cycle components :
    - entry
    - exit
    - stop-loss
    - take-profit
    - breakeven
    - dynamic-stop-loss
    - dynamic-take-profit

- avoir un filtragep pour le stop-loss, le faire qu'après une cloture de bougie ou un autre filtrage genre MA...
  - par exemple sl/tp à close 1min car en matchant avec un step de 60 ça offre une bonne perf et donc il faudrait
    qu'en live ça soit aussi une cloture en m1 par contre ça peut géner pour mettre un limit order

Secondaire
==========

- monitoring
  - est-ce que le monitor communique avec un socket (zMQ, o3d::net) ou au travers de REDIS ?
  - cli simple monitor one command at time
  - cli advanced monitor ncursuse
  - web monitor (voir version python)

- events to REDIS
  - strategy data
    - analysers data
       - ohlc(s)
       - indicators
       - states
       - others
    - contexts data
      - trade components

- connectors
  - implementer coté strategie
    - order create, update, delete
    - position update, close
    - binance spot, kraken spot, bitmex futures, ig CFD

- position trade
  - open, close, remove, modify tp, modify sl, order events, position events

- live handler


Tertaire
========

- spot trade
  - open, close, remove, modify tp, modify sl, order events, position events

- indicators :
  - volume profile
  - composite volume profile

- tick-bar based strategy (non timeframe based)

- connector postgresql à terminer
  - postgresql load market liquidation
  - postgresql save market liquidation data
  - postgresql save market info data
  - postgresql save OHLCs data

- replication mode
  - mode live mais connexion à une source de donnée en WebSocket ou REST et simples signaux buy/sell/update
    - update peut être cancel, modifier un sl/tp/breakeven, partial exit

- trade check and repair


Pas important
=============

- connector mysql pas important

- margin trade
  - open, close, remove, modify tp, modify sl, order events, position events

- learning / trainer / optimizer
